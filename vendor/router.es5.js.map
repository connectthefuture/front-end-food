{"version":3,"names":[],"mappings":"","sources":["router.es5.js"],"sourcesContent":[" 'use strict';\n\n /*\n  * A module for adding new a routing system Angular 1.\n  */\n angular.module('ngNewRouter', [])\n     .factory('$router', routerFactory)\n     .value('$routeParams', {})\n     .provider('$componentLoader', $componentLoaderProvider)\n     .provider('$pipeline', pipelineProvider)\n     .factory('$$pipeline', privatePipelineFactory)\n     .factory('$setupRoutersStep', setupRoutersStepFactory)\n     .factory('$initLocalsStep', initLocalsStepFactory)\n     .factory('$initControllersStep', initControllersStepFactory)\n     .factory('$runCanDeactivateHookStep', runCanDeactivateHookStepFactory)\n     .factory('$runCanActivateHookStep', runCanActivateHookStepFactory)\n     .factory('$loadTemplatesStep', loadTemplatesStepFactory)\n     .value('$activateStep', activateStepValue)\n     .directive('ngViewport', ngViewportDirective)\n     .directive('ngViewport', ngViewportFillContentDirective)\n     .directive('ngLink', ngLinkDirective)\n     .directive('a', anchorLinkDirective)\n\n\n\n\n /*\n  * A module for inspecting controller constructors\n  */\n angular.module('ng')\n     .provider('$controllerIntrospector', $controllerIntrospectorProvider)\n     .config(controllerProviderDecorator);\n\n /*\n  * decorates with routing info\n  */\n function controllerProviderDecorator($controllerProvider, $controllerIntrospectorProvider) {\n     var register = $controllerProvider.register;\n     $controllerProvider.register = function(name, ctrl) {\n         $controllerIntrospectorProvider.register(name, ctrl);\n         return register.apply(this, arguments);\n     };\n }\n controllerProviderDecorator.$inject = [\"$controllerProvider\", \"$controllerIntrospectorProvider\"];\n\n /*\n  * private service that holds route mappings for each controller\n  */\n function $controllerIntrospectorProvider() {\n     var controllers = [];\n     var onControllerRegistered = null;\n     return {\n         register: function(name, constructor) {\n             if (angular.isArray(constructor)) {\n                 constructor = constructor[constructor.length - 1];\n             }\n             if (constructor.$routeConfig) {\n                 if (onControllerRegistered) {\n                     onControllerRegistered(name, constructor.$routeConfig);\n                 } else {\n                     controllers.push({\n                         name: name,\n                         config: constructor.$routeConfig\n                     });\n                 }\n             }\n         },\n         $get: ['$componentLoader', function($componentLoader) {\n             return function(newOnControllerRegistered) {\n                 onControllerRegistered = function(name, constructor) {\n                     name = $componentLoader.component(name);\n                     return newOnControllerRegistered(name, constructor);\n                 };\n                 while (controllers.length > 0) {\n                     var rule = controllers.pop();\n                     onControllerRegistered(rule.name, rule.config);\n                 }\n             }\n         }]\n     }\n }\n\n function routerFactory($$rootRouter, $rootScope, $location, $$grammar, $controllerIntrospector) {\n\n     $controllerIntrospector(function(name, config) {\n         $$grammar.config(name, config);\n     });\n\n     $rootScope.$watch(function() {\n         return $location.path();\n     }, function(newUrl) {\n         $$rootRouter.navigate(newUrl);\n     });\n\n     var nav = $$rootRouter.navigate;\n     $$rootRouter.navigate = function(url) {\n         return nav.call(this, url).then(function(newUrl) {\n             if (newUrl) {\n                 $location.path(newUrl);\n             }\n         });\n     }\n\n     return $$rootRouter;\n }\n routerFactory.$inject = [\"$$rootRouter\", \"$rootScope\", \"$location\", \"$$grammar\", \"$controllerIntrospector\"];\n\n /**\n  * @name ngViewport\n  *\n  * @description\n  * An ngViewport is where resolved content goes.\n  *\n  * ## Use\n  *\n  * ```html\n  * <div router-viewport=\"name\"></div>\n  * ```\n  *\n  * The value for the `ngViewport` attribute is optional.\n  */\n function ngViewportDirective($animate, $injector, $q, $router) {\n     var rootRouter = $router;\n\n     return {\n         restrict: 'AE',\n         transclude: 'element',\n         terminal: true,\n         priority: 400,\n         require: ['?^^ngViewport', 'ngViewport'],\n         link: viewportLink,\n         controller: function() {},\n         controllerAs: '$$ngViewport'\n     };\n\n     function invoke(method, context, instruction) {\n         return $injector.invoke(method, context, instruction.locals);\n     }\n\n     function viewportLink(scope, $element, attrs, ctrls, $transclude) {\n         var viewportName = attrs.ngViewport || 'default',\n             parentCtrl = ctrls[0],\n             myCtrl = ctrls[1],\n             router = (parentCtrl && parentCtrl.$$router) || rootRouter;\n\n         var currentScope,\n             newScope,\n             currentController,\n             currentElement,\n             previousLeaveAnimation,\n             previousInstruction;\n\n         function cleanupLastView() {\n             if (previousLeaveAnimation) {\n                 $animate.cancel(previousLeaveAnimation);\n                 previousLeaveAnimation = null;\n             }\n\n             if (currentScope) {\n                 currentScope.$destroy();\n                 currentScope = null;\n             }\n             if (currentElement) {\n                 previousLeaveAnimation = $animate.leave(currentElement);\n                 previousLeaveAnimation.then(function() {\n                     previousLeaveAnimation = null;\n                 });\n                 currentElement = null;\n             }\n         }\n\n         router.registerViewport({\n             canDeactivate: function(instruction) {\n                 if (currentController && currentController.canDeactivate) {\n                     return invoke(currentController.canDeactivate, currentController, instruction);\n                 }\n                 return true;\n             },\n             activate: function(instruction) {\n                 var nextInstruction = serializeInstruction(instruction);\n                 if (nextInstruction === previousInstruction) {\n                     return;\n                 }\n\n                 instruction.locals.$scope = newScope = scope.$new();\n                 myCtrl.$$router = instruction.router;\n                 myCtrl.$$template = instruction.template;\n                 var componentName = instruction.component;\n                 var clone = $transclude(newScope, function(clone) {\n                     $animate.enter(clone, null, currentElement || $element);\n                     cleanupLastView();\n                 });\n\n                 var newController = instruction.controller;\n                 newScope[componentName] = newController;\n\n                 var result;\n                 if (currentController && currentController.deactivate) {\n                     result = $q.when(invoke(currentController.deactivate, currentController, instruction));\n                 }\n\n                 currentController = newController;\n\n                 currentElement = clone;\n                 currentScope = newScope;\n\n                 previousInstruction = nextInstruction;\n\n                 // finally, run the hook\n                 if (newController.activate) {\n                     var activationResult = $q.when(invoke(newController.activate, newController, instruction));\n                     if (result) {\n                         return result.then(activationResult);\n                     } else {\n                         return activationResult;\n                     }\n                 }\n                 return result;\n             }\n         }, viewportName);\n     }\n\n     // TODO: how best to serialize?\n     function serializeInstruction(instruction) {\n         return JSON.stringify({\n             path: instruction.path,\n             component: instruction.component,\n             params: Object.keys(instruction.params).reduce(function(acc, key) {\n                 return (key !== 'childRoute' && (acc[key] = instruction.params[key])), acc;\n             }, {})\n         });\n     }\n }\n ngViewportDirective.$inject = [\"$animate\", \"$injector\", \"$q\", \"$router\"];\n\n function ngViewportFillContentDirective($compile) {\n     return {\n         restrict: 'EA',\n         priority: -400,\n         require: 'ngViewport',\n         link: function(scope, $element, attrs, ctrl) {\n             var template = ctrl.$$template;\n             $element.html(template);\n             var link = $compile($element.contents());\n             link(scope);\n         }\n     };\n }\n ngViewportFillContentDirective.$inject = [\"$compile\"];\n\n function makeComponentString(name) {\n     return [\n         '<router-component component-name=\"', name, '\">',\n         '</router-component>'\n     ].join('');\n }\n\n\n var LINK_MICROSYNTAX_RE = /^(.+?)(?:\\((.*)\\))?$/;\n /**\n  * @name ngLink\n  * @description\n  * Lets you link to different parts of the app, and automatically generates hrefs.\n  *\n  * ## Use\n  * The directive uses a simple syntax: `router-link=\"componentName({ param: paramValue })\"`\n  *\n  * ## Example\n  *\n  * ```js\n  * angular.module('myApp', ['ngFuturisticRouter'])\n  *   .controller('AppController', ['$router', function($router) {\n  *     $router.config({ path: '/user/:id' component: 'user' });\n  *     this.user = { name: 'Brian', id: 123 };\n  *   });\n  * ```\n  *\n  * ```html\n  * <div ng-controller=\"AppController as app\">\n  *   <a router-link=\"user({id: app.user.id})\">{{app.user.name}}</a>\n  * </div>\n  * ```\n  */\n function ngLinkDirective($router, $location, $parse) {\n     var rootRouter = $router;\n\n     return {\n         require: '?^^ngViewport',\n         restrict: 'A',\n         link: ngLinkDirectiveLinkFn\n     };\n\n     function ngLinkDirectiveLinkFn(scope, elt, attrs, ctrl) {\n         var router = (ctrl && ctrl.$$router) || rootRouter;\n         if (!router) {\n             return;\n         }\n\n         var link = attrs.ngLink || '';\n         var parts = link.match(LINK_MICROSYNTAX_RE);\n         var routeName = parts[1];\n         var routeParams = parts[2];\n         var url;\n\n         if (routeParams) {\n             var routeParamsGetter = $parse(routeParams);\n             // we can avoid adding a watcher if it's a literal\n             if (routeParamsGetter.constant) {\n                 var params = routeParamsGetter();\n                 url = '.' + router.generate(routeName, params);\n                 elt.attr('href', url);\n             } else {\n                 scope.$watch(function() {\n                     return routeParamsGetter(scope);\n                 }, function(params) {\n                     url = '.' + router.generate(routeName, params);\n                     elt.attr('href', url);\n                 }, true);\n             }\n         } else {\n             url = '.' + router.generate(routeName);\n             elt.attr('href', url);\n         }\n     }\n }\n ngLinkDirective.$inject = [\"$router\", \"$location\", \"$parse\"];\n\n\n function anchorLinkDirective($router) {\n     return {\n         restrict: 'E',\n         link: function(scope, element) {\n             // If the linked element is not an anchor tag anymore, do nothing\n             if (element[0].nodeName.toLowerCase() !== 'a') return;\n\n             // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n             var hrefAttrName = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?\n                 'xlink:href' : 'href';\n\n             element.on('click', function(event) {\n                 var href = element.attr(hrefAttrName);\n                 if (!href) {\n                     event.preventDefault();\n                 }\n                 if ($router.recognize(href)) {\n                     $router.navigate(href);\n                     event.preventDefault();\n                 }\n             });\n         }\n     }\n }\n anchorLinkDirective.$inject = [\"$router\"];\n\n function setupRoutersStepFactory() {\n     return function(instruction) {\n         return instruction.router.makeDescendantRouters(instruction);\n     }\n }\n\n /*\n  * $initLocalsStep\n  */\n function initLocalsStepFactory() {\n     return function initLocals(instruction) {\n         return instruction.router.traverseInstruction(instruction, function(instruction) {\n             return instruction.locals = {\n                 $router: instruction.router,\n                 $routeParams: (instruction.params || {})\n             };\n         });\n     }\n }\n\n /*\n  * $initControllersStep\n  */\n function initControllersStepFactory($controller, $componentLoader) {\n     return function initControllers(instruction) {\n         return instruction.router.traverseInstruction(instruction, function(instruction) {\n             var controllerName = $componentLoader.controllerName(instruction.component);\n             var locals = instruction.locals;\n             var ctrl;\n             try {\n                 ctrl = $controller(controllerName, locals);\n             } catch (e) {\n                 console.warn && console.warn('Could not instantiate controller', controllerName);\n                 ctrl = $controller(angular.noop, locals);\n             }\n             return instruction.controller = ctrl;\n         });\n     }\n }\n initControllersStepFactory.$inject = [\"$controller\", \"$componentLoader\"];\n\n function runCanDeactivateHookStepFactory() {\n     return function runCanDeactivateHook(instruction) {\n         return instruction.router.canDeactivatePorts(instruction);\n     };\n }\n\n function runCanActivateHookStepFactory($injector) {\n\n     function invoke(method, context, instruction) {\n         return $injector.invoke(method, context, {\n             $routeParams: instruction.params\n         });\n     }\n\n     return function runCanActivateHook(instruction) {\n         return instruction.router.traverseInstruction(instruction, function(instruction) {\n             var controller = instruction.controller;\n             return !controller.canActivate || invoke(controller.canActivate, controller, instruction);\n         });\n     }\n }\n runCanActivateHookStepFactory.$inject = [\"$injector\"];\n\n function loadTemplatesStepFactory($componentLoader, $templateRequest) {\n     return function loadTemplates(instruction) {\n         return instruction.router.traverseInstruction(instruction, function(instruction) {\n             var componentTemplateUrl = $componentLoader.template(instruction.component);\n             return $templateRequest(componentTemplateUrl).then(function(templateHtml) {\n                 return instruction.template = templateHtml;\n             });\n         });\n     };\n }\n loadTemplatesStepFactory.$inject = [\"$componentLoader\", \"$templateRequest\"];\n\n\n function activateStepValue(instruction) {\n     return instruction.router.activatePorts(instruction);\n }\n\n\n function pipelineProvider() {\n     var stepConfiguration;\n\n     var protoStepConfiguration = [\n         '$setupRoutersStep',\n         '$initLocalsStep',\n         '$initControllersStep',\n         '$runCanDeactivateHookStep',\n         '$runCanActivateHookStep',\n         '$loadTemplatesStep',\n         '$activateStep'\n     ];\n\n     return {\n         steps: protoStepConfiguration.slice(0),\n         config: function(newConfig) {\n             protoStepConfiguration = newConfig;\n         },\n         $get: [\"$injector\", \"$q\", function($injector, $q) {\n             stepConfiguration = protoStepConfiguration.map(function(step) {\n                 return $injector.get(step);\n             });\n             return {\n                 process: function(instruction) {\n                     // make a copy\n                     var steps = stepConfiguration.slice(0);\n\n                     function processOne(result) {\n                         if (steps.length === 0) {\n                             return result;\n                         }\n                         var step = steps.shift();\n                         return $q.when(step(instruction)).then(processOne);\n                     }\n\n                     return processOne();\n                 }\n             }\n         }]\n     };\n }\n\n\n /**\n  * @name $componentLoaderProvider\n  * @description\n  *\n  * This lets you configure conventions for what controllers are named and where to load templates from.\n  *\n  * The default behavior is to dasherize and serve from `./components`. A component called `myWidget`\n  * uses a controller named `MyWidgetController` and a template loaded from `./components/my-widget/my-widget.html`.\n  *\n  * A component is:\n  * - a controller\n  * - a template\n  * - an optional router\n  *\n  * This service makes it easy to group all of them into a single concept.\n  */\n function $componentLoaderProvider() {\n\n     var DEFAULT_SUFFIX = 'Controller';\n\n     var componentToCtrl = function componentToCtrlDefault(name) {\n         return name[0].toUpperCase() + name.substr(1) + DEFAULT_SUFFIX;\n     };\n\n     var componentToTemplate = function componentToTemplateDefault(name) {\n         var dashName = dashCase(name);\n         return './components/' + dashName + '/' + dashName + '.html';\n     };\n\n     var ctrlToComponent = function ctrlToComponentDefault(name) {\n         return name[0].toLowerCase() + name.substr(1, name.length - DEFAULT_SUFFIX.length - 1);\n     };\n\n     return {\n         $get: function() {\n             return {\n                 controllerName: componentToCtrl,\n                 template: componentToTemplate,\n                 component: ctrlToComponent\n             };\n         },\n\n         /**\n          * @name $componentLoaderProvider#setCtrlNameMapping\n          * @description takes a function for mapping component names to component controller names\n          */\n         setCtrlNameMapping: function(newFn) {\n             componentToCtrl = newFn;\n             return this;\n         },\n\n         /**\n          * @name $componentLoaderProvider#setCtrlNameMapping\n          * @description takes a function for mapping component controller names to component names\n          */\n         setComponentFromCtrlMapping: function(newFn) {\n             ctrlToComponent = newFn;\n             return this;\n         },\n\n         /**\n          * @name $componentLoaderProvider#setTemplateMapping\n          * @description takes a function for mapping component names to component template URLs\n          */\n         setTemplateMapping: function(newFn) {\n             componentToTemplate = newFn;\n             return this;\n         }\n     };\n }\n\n // this is a hack as a result of the build system used to transpile\n function privatePipelineFactory($pipeline) {\n     return $pipeline;\n }\n privatePipelineFactory.$inject = [\"$pipeline\"];\n\n\n function dashCase(str) {\n     return str.replace(/([A-Z])/g, function($1) {\n         return '-' + $1.toLowerCase();\n     });\n }\n\n\n angular.module('ngNewRouter').factory('$$rootRouter', ['$q', '$$grammar', '$$pipeline', function($q, $$grammar, $$pipeline) {\n     /*\n      * artisinal, handcrafted subset of the traceur runtime for picky webdevs\n      */\n\n     var $defineProperty = Object.defineProperty,\n         $defineProperties = Object.defineProperties,\n         $create = Object.create,\n         $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n         $getOwnPropertyNames = Object.getOwnPropertyNames,\n         $getPrototypeOf = Object.getPrototypeOf;\n\n     function createClass(ctor, object, staticObject, superClass) {\n         $defineProperty(object, 'constructor', {\n             value: ctor,\n             configurable: true,\n             enumerable: false,\n             writable: true\n         });\n         if (arguments.length > 3) {\n             if (typeof superClass === 'function')\n                 ctor.__proto__ = superClass;\n             ctor.prototype = $create(getProtoParent(superClass), getDescriptors(object));\n         } else {\n             ctor.prototype = object;\n         }\n         $defineProperty(ctor, 'prototype', {\n             configurable: false,\n             writable: false\n         });\n         return $defineProperties(ctor, getDescriptors(staticObject));\n     }\n\n     function getProtoParent(superClass) {\n         if (typeof superClass === 'function') {\n             var prototype = superClass.prototype;\n             if (Object(prototype) === prototype || prototype === null)\n                 return superClass.prototype;\n             throw new TypeError('super prototype must be an Object or null');\n         }\n         if (superClass === null)\n             return null;\n         throw new TypeError((\"Super expression must either be null or a function, not \" + typeof superClass + \".\"));\n     }\n\n     function getDescriptors(object) {\n         var descriptors = {};\n         var names = $getOwnPropertyNames(object);\n         for (var i = 0; i < names.length; i++) {\n             var name = names[i];\n             descriptors[name] = $getOwnPropertyDescriptor(object, name);\n         }\n         // TODO: someday you might use symbols and you'll have to re-evaluate\n         //       your life choices that led to the creation of this file\n\n         // var symbols = getOwnPropertySymbols(object);\n         // for (var i = 0; i < symbols.length; i++) {\n         //   var symbol = symbols[i];\n         //   descriptors[$traceurRuntime.toProperty(symbol)] = $getOwnPropertyDescriptor(object, $traceurRuntime.toProperty(symbol));\n         // }\n         return descriptors;\n     }\n\n     function superDescriptor(homeObject, name) {\n         var proto = $getPrototypeOf(homeObject);\n         do {\n             var result = $getOwnPropertyDescriptor(proto, name);\n             if (result)\n                 return result;\n             proto = $getPrototypeOf(proto);\n         } while (proto);\n         return undefined;\n     }\n\n     function superCall(self, homeObject, name, args) {\n         return superGet(self, homeObject, name).apply(self, args);\n     }\n\n     function superGet(self, homeObject, name) {\n         var descriptor = superDescriptor(homeObject, name);\n         if (descriptor) {\n             if (!descriptor.get)\n                 return descriptor.value;\n             return descriptor.get.call(self);\n         }\n         return undefined;\n     }\n\n     \"use strict\";\n     var Router = function Router(grammar, pipeline, parent, name) {\n         this.name = name;\n         this.parent = parent || null;\n         this.navigating = false;\n         this.ports = {};\n         this.children = {};\n         this.registry = grammar;\n         this.pipeline = pipeline;\n     };\n     (createClass)(Router, {\n         childRouter: function() {\n             var name = arguments[0] !== (void 0) ? arguments[0] : 'default';\n             if (!this.children[name]) {\n                 this.children[name] = new ChildRouter(this, name);\n             }\n             return this.children[name];\n         },\n         registerViewport: function(view) {\n             var name = arguments[1] !== (void 0) ? arguments[1] : 'default';\n             this.ports[name] = view;\n             return this.renavigate();\n         },\n         config: function(mapping) {\n             this.registry.config(this.name, mapping);\n             return this.renavigate();\n         },\n         navigate: function(url) {\n             var $__0 = this;\n             if (this.navigating) {\n                 return $q.when();\n             }\n             this.lastNavigationAttempt = url;\n             var instruction = this.recognize(url);\n             if (!instruction) {\n                 return $q.reject();\n             }\n             this._startNavigating();\n             instruction.router = this;\n             return this.pipeline.process(instruction).then((function() {\n                 return $__0._finishNavigating();\n             }), (function() {\n                 return $__0._finishNavigating();\n             })).then((function() {\n                 return instruction.canonicalUrl;\n             }));\n         },\n         _startNavigating: function() {\n             this.navigating = true;\n         },\n         _finishNavigating: function() {\n             this.navigating = false;\n         },\n         makeDescendantRouters: function(instruction) {\n             this.traverseInstructionSync(instruction, (function(instruction, childInstruction) {\n                 childInstruction.router = instruction.router.childRouter(childInstruction.component);\n             }));\n         },\n         traverseInstructionSync: function(instruction, fn) {\n             var $__0 = this;\n             forEach(instruction.viewports, (function(childInstruction, viewportName) {\n                 return fn(instruction, childInstruction);\n             }));\n             forEach(instruction.viewports, (function(childInstruction) {\n                 return $__0.traverseInstructionSync(childInstruction, fn);\n             }));\n         },\n         traverseInstruction: function(instruction, fn) {\n             if (!instruction) {\n                 return $q.when();\n             }\n             return mapObjAsync(instruction.viewports, (function(childInstruction, viewportName) {\n                 return boolToPromise(fn(childInstruction, viewportName));\n             })).then((function() {\n                 return mapObjAsync(instruction.viewports, (function(childInstruction, viewportName) {\n                     return childInstruction.router.traverseInstruction(childInstruction, fn);\n                 }));\n             }));\n         },\n         activatePorts: function(instruction) {\n             return this.queryViewports((function(port, name) {\n                 return port.activate(instruction.viewports[name]);\n             })).then((function() {\n                 return mapObjAsync(instruction.viewports, (function(instruction) {\n                     return instruction.router.activatePorts(instruction);\n                 }));\n             }));\n         },\n         canDeactivatePorts: function(instruction) {\n             return this.traversePorts((function(port, name) {\n                 return boolToPromise(port.canDeactivate(instruction.viewports[name]));\n             }));\n         },\n         traversePorts: function(fn) {\n             var $__0 = this;\n             return this.queryViewports(fn).then((function() {\n                 return mapObjAsync($__0.children, (function(child) {\n                     return child.traversePorts(fn);\n                 }));\n             }));\n         },\n         queryViewports: function(fn) {\n             return mapObjAsync(this.ports, fn);\n         },\n         recognize: function(url) {\n             return this.registry.recognize(url);\n         },\n         renavigate: function() {\n             var renavigateDestination = this.previousUrl || this.lastNavigationAttempt;\n             if (!this.navigating && renavigateDestination) {\n                 return this.navigate(renavigateDestination);\n             } else {\n                 return $q.when();\n             }\n         },\n         generate: function(name, params) {\n             return this.registry.generate(name, params);\n         }\n     }, {});\n     Object.defineProperty(Router, \"parameters\", {\n         get: function() {\n             return [\n                 [Grammar],\n                 [Pipeline],\n                 [],\n                 []\n             ];\n         }\n     });\n     Object.defineProperty(Router.prototype.generate, \"parameters\", {\n         get: function() {\n             return [\n                 [$traceurRuntime.type.string],\n                 []\n             ];\n         }\n     });\n     var RootRouter = function RootRouter(grammar, pipeline) {\n         superCall(this, $RootRouter.prototype, \"constructor\", [grammar, pipeline, null, '/']);\n     };\n     var $RootRouter = RootRouter;\n     (createClass)(RootRouter, {}, {}, Router);\n     Object.defineProperty(RootRouter, \"parameters\", {\n         get: function() {\n             return [\n                 [Grammar],\n                 [Pipeline]\n             ];\n         }\n     });\n     var ChildRouter = function ChildRouter(parent, name) {\n         superCall(this, $ChildRouter.prototype, \"constructor\", [parent.registry, parent.pipeline, parent, name]);\n         this.parent = parent;\n     };\n     var $ChildRouter = ChildRouter;\n     (createClass)(ChildRouter, {}, {}, Router);\n\n     function forEach(obj, fn) {\n         Object.keys(obj).forEach((function(key) {\n             return fn(obj[key], key);\n         }));\n     }\n\n     function mapObjAsync(obj, fn) {\n         return $q.all(mapObj(obj, fn));\n     }\n\n     function mapObj(obj, fn) {\n         var result = [];\n         Object.keys(obj).forEach((function(key) {\n             return result.push(fn(obj[key], key));\n         }));\n         return result;\n     }\n\n     function boolToPromise(value) {\n         return value ? $q.when(value) : $q.reject();\n     }\n     return new RootRouter($$grammar, $$pipeline);\n }]);\n\n\n angular.module('ngNewRouter').factory('$$grammar', ['$q', function($q) {\n     /*\n      * artisinal, handcrafted subset of the traceur runtime for picky webdevs\n      */\n\n     var $defineProperty = Object.defineProperty,\n         $defineProperties = Object.defineProperties,\n         $create = Object.create,\n         $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n         $getOwnPropertyNames = Object.getOwnPropertyNames,\n         $getPrototypeOf = Object.getPrototypeOf;\n\n     function createClass(ctor, object, staticObject, superClass) {\n         $defineProperty(object, 'constructor', {\n             value: ctor,\n             configurable: true,\n             enumerable: false,\n             writable: true\n         });\n         if (arguments.length > 3) {\n             if (typeof superClass === 'function')\n                 ctor.__proto__ = superClass;\n             ctor.prototype = $create(getProtoParent(superClass), getDescriptors(object));\n         } else {\n             ctor.prototype = object;\n         }\n         $defineProperty(ctor, 'prototype', {\n             configurable: false,\n             writable: false\n         });\n         return $defineProperties(ctor, getDescriptors(staticObject));\n     }\n\n     function getProtoParent(superClass) {\n         if (typeof superClass === 'function') {\n             var prototype = superClass.prototype;\n             if (Object(prototype) === prototype || prototype === null)\n                 return superClass.prototype;\n             throw new TypeError('super prototype must be an Object or null');\n         }\n         if (superClass === null)\n             return null;\n         throw new TypeError((\"Super expression must either be null or a function, not \" + typeof superClass + \".\"));\n     }\n\n     function getDescriptors(object) {\n         var descriptors = {};\n         var names = $getOwnPropertyNames(object);\n         for (var i = 0; i < names.length; i++) {\n             var name = names[i];\n             descriptors[name] = $getOwnPropertyDescriptor(object, name);\n         }\n         // TODO: someday you might use symbols and you'll have to re-evaluate\n         //       your life choices that led to the creation of this file\n\n         // var symbols = getOwnPropertySymbols(object);\n         // for (var i = 0; i < symbols.length; i++) {\n         //   var symbol = symbols[i];\n         //   descriptors[$traceurRuntime.toProperty(symbol)] = $getOwnPropertyDescriptor(object, $traceurRuntime.toProperty(symbol));\n         // }\n         return descriptors;\n     }\n\n     function superDescriptor(homeObject, name) {\n         var proto = $getPrototypeOf(homeObject);\n         do {\n             var result = $getOwnPropertyDescriptor(proto, name);\n             if (result)\n                 return result;\n             proto = $getPrototypeOf(proto);\n         } while (proto);\n         return undefined;\n     }\n\n     function superCall(self, homeObject, name, args) {\n         return superGet(self, homeObject, name).apply(self, args);\n     }\n\n     function superGet(self, homeObject, name) {\n         var descriptor = superDescriptor(homeObject, name);\n         if (descriptor) {\n             if (!descriptor.get)\n                 return descriptor.value;\n             return descriptor.get.call(self);\n         }\n         return undefined;\n     }\n\n     \"use strict\";\n     var RouteRecognizer = (function() {\n         var map = (function() {\n             function Target(path, matcher, delegate) {\n                 this.path = path;\n                 this.matcher = matcher;\n                 this.delegate = delegate;\n             }\n             Target.prototype = {\n                 to: function(target, callback) {\n                     var delegate = this.delegate;\n                     if (delegate && delegate.willAddRoute) {\n                         target = delegate.willAddRoute(this.matcher.target, target);\n                     }\n                     this.matcher.add(this.path, target);\n                     if (callback) {\n                         if (callback.length === 0) {\n                             throw new Error(\"You must have an argument in the function passed to `to`\");\n                         }\n                         this.matcher.addChild(this.path, target, callback, this.delegate);\n                     }\n                     return this;\n                 }\n             };\n\n             function Matcher(target) {\n                 this.routes = {};\n                 this.children = {};\n                 this.target = target;\n             }\n             Matcher.prototype = {\n                 add: function(path, handler) {\n                     this.routes[path] = handler;\n                 },\n                 addChild: function(path, target, callback, delegate) {\n                     var matcher = new Matcher(target);\n                     this.children[path] = matcher;\n                     var match = generateMatch(path, matcher, delegate);\n                     if (delegate && delegate.contextEntered) {\n                         delegate.contextEntered(target, match);\n                     }\n                     callback(match);\n                 }\n             };\n\n             function generateMatch(startingPath, matcher, delegate) {\n                 return function(path, nestedCallback) {\n                     var fullPath = startingPath + path;\n                     if (nestedCallback) {\n                         nestedCallback(generateMatch(fullPath, matcher, delegate));\n                     } else {\n                         return new Target(startingPath + path, matcher, delegate);\n                     }\n                 };\n             }\n\n             function addRoute(routeArray, path, handler) {\n                 var len = 0;\n                 for (var i = 0,\n                         l = routeArray.length; i < l; i++) {\n                     len += routeArray[i].path.length;\n                 }\n                 path = path.substr(len);\n                 var route = {\n                     path: path,\n                     handler: handler\n                 };\n                 routeArray.push(route);\n             }\n\n             function eachRoute(baseRoute, matcher, callback, binding) {\n                 var routes = matcher.routes;\n                 for (var path in routes) {\n                     if (routes.hasOwnProperty(path)) {\n                         var routeArray = baseRoute.slice();\n                         addRoute(routeArray, path, routes[path]);\n                         if (matcher.children[path]) {\n                             eachRoute(routeArray, matcher.children[path], callback, binding);\n                         } else {\n                             callback.call(binding, routeArray);\n                         }\n                     }\n                 }\n             }\n             return function(callback, addRouteCallback) {\n                 var matcher = new Matcher();\n                 callback(generateMatch(\"\", matcher, this.delegate));\n                 eachRoute([], matcher, function(route) {\n                     if (addRouteCallback) {\n                         addRouteCallback(this, route);\n                     } else {\n                         this.add(route);\n                     }\n                 }, this);\n             };\n         }());\n         var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\'];\n         var escapeRegex = new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'g');\n\n         function isArray(test) {\n             return Object.prototype.toString.call(test) === \"[object Array]\";\n         }\n\n         function StaticSegment(string) {\n             this.string = string;\n         }\n         StaticSegment.prototype = {\n             eachChar: function(callback) {\n                 var string = this.string,\n                     ch;\n                 for (var i = 0,\n                         l = string.length; i < l; i++) {\n                     ch = string.charAt(i);\n                     callback({\n                         validChars: ch\n                     });\n                 }\n             },\n             regex: function() {\n                 return this.string.replace(escapeRegex, '\\\\$1');\n             },\n             generate: function() {\n                 return this.string;\n             }\n         };\n\n         function DynamicSegment(name) {\n             this.name = name;\n         }\n         DynamicSegment.prototype = {\n             eachChar: function(callback) {\n                 callback({\n                     invalidChars: \"/\",\n                     repeat: true\n                 });\n             },\n             regex: function() {\n                 return \"([^/]+)\";\n             },\n             generate: function(params) {\n                 return params[this.name];\n             }\n         };\n\n         function StarSegment(name) {\n             this.name = name;\n         }\n         StarSegment.prototype = {\n             eachChar: function(callback) {\n                 callback({\n                     invalidChars: \"\",\n                     repeat: true\n                 });\n             },\n             regex: function() {\n                 return \"(.+)\";\n             },\n             generate: function(params) {\n                 return params[this.name];\n             }\n         };\n\n         function EpsilonSegment() {}\n         EpsilonSegment.prototype = {\n             eachChar: function() {},\n             regex: function() {\n                 return \"\";\n             },\n             generate: function() {\n                 return \"\";\n             }\n         };\n\n         function parse(route, names, types) {\n             if (route.charAt(0) === \"/\") {\n                 route = route.substr(1);\n             }\n             var segments = route.split(\"/\"),\n                 results = [];\n             for (var i = 0,\n                     l = segments.length; i < l; i++) {\n                 var segment = segments[i],\n                     match;\n                 if (match = segment.match(/^:([^\\/]+)$/)) {\n                     results.push(new DynamicSegment(match[1]));\n                     names.push(match[1]);\n                     types.dynamics++;\n                 } else if (match = segment.match(/^\\*([^\\/]+)$/)) {\n                     results.push(new StarSegment(match[1]));\n                     names.push(match[1]);\n                     types.stars++;\n                 } else if (segment === \"\") {\n                     results.push(new EpsilonSegment());\n                 } else {\n                     results.push(new StaticSegment(segment));\n                     types.statics++;\n                 }\n             }\n             return results;\n         }\n\n         function State(charSpec) {\n             this.charSpec = charSpec;\n             this.nextStates = [];\n         }\n         State.prototype = {\n             get: function(charSpec) {\n                 var nextStates = this.nextStates;\n                 for (var i = 0,\n                         l = nextStates.length; i < l; i++) {\n                     var child = nextStates[i];\n                     var isEqual = child.charSpec.validChars === charSpec.validChars;\n                     isEqual = isEqual && child.charSpec.invalidChars === charSpec.invalidChars;\n                     if (isEqual) {\n                         return child;\n                     }\n                 }\n             },\n             put: function(charSpec) {\n                 var state;\n                 if (state = this.get(charSpec)) {\n                     return state;\n                 }\n                 state = new State(charSpec);\n                 this.nextStates.push(state);\n                 if (charSpec.repeat) {\n                     state.nextStates.push(state);\n                 }\n                 return state;\n             },\n             match: function(ch) {\n                 var nextStates = this.nextStates,\n                     child,\n                     charSpec,\n                     chars;\n                 var returned = [];\n                 for (var i = 0,\n                         l = nextStates.length; i < l; i++) {\n                     child = nextStates[i];\n                     charSpec = child.charSpec;\n                     if (typeof(chars = charSpec.validChars) !== 'undefined') {\n                         if (chars.indexOf(ch) !== -1) {\n                             returned.push(child);\n                         }\n                     } else if (typeof(chars = charSpec.invalidChars) !== 'undefined') {\n                         if (chars.indexOf(ch) === -1) {\n                             returned.push(child);\n                         }\n                     }\n                 }\n                 return returned;\n             }\n         };\n\n         function sortSolutions(states) {\n             return states.sort(function(a, b) {\n                 if (a.types.stars !== b.types.stars) {\n                     return a.types.stars - b.types.stars;\n                 }\n                 if (a.types.stars) {\n                     if (a.types.statics !== b.types.statics) {\n                         return b.types.statics - a.types.statics;\n                     }\n                     if (a.types.dynamics !== b.types.dynamics) {\n                         return b.types.dynamics - a.types.dynamics;\n                     }\n                 }\n                 if (a.types.dynamics !== b.types.dynamics) {\n                     return a.types.dynamics - b.types.dynamics;\n                 }\n                 if (a.types.statics !== b.types.statics) {\n                     return b.types.statics - a.types.statics;\n                 }\n                 return 0;\n             });\n         }\n\n         function recognizeChar(states, ch) {\n             var nextStates = [];\n             for (var i = 0,\n                     l = states.length; i < l; i++) {\n                 var state = states[i];\n                 nextStates = nextStates.concat(state.match(ch));\n             }\n             return nextStates;\n         }\n         var oCreate = Object.create || function(proto) {\n             function F() {}\n             F.prototype = proto;\n             return new F();\n         };\n\n         function RecognizeResults(queryParams) {\n             this.queryParams = queryParams || {};\n         }\n         RecognizeResults.prototype = oCreate({\n             splice: Array.prototype.splice,\n             slice: Array.prototype.slice,\n             push: Array.prototype.push,\n             length: 0,\n             queryParams: null\n         });\n\n         function findHandler(state, path, queryParams) {\n             var handlers = state.handlers,\n                 regex = state.regex;\n             var captures = path.match(regex),\n                 currentCapture = 1;\n             var result = new RecognizeResults(queryParams);\n             for (var i = 0,\n                     l = handlers.length; i < l; i++) {\n                 var handler = handlers[i],\n                     names = handler.names,\n                     params = {};\n                 for (var j = 0,\n                         m = names.length; j < m; j++) {\n                     params[names[j]] = captures[currentCapture++];\n                 }\n                 result.push({\n                     handler: handler.handler,\n                     params: params,\n                     isDynamic: !!names.length\n                 });\n             }\n             return result;\n         }\n\n         function addSegment(currentState, segment) {\n             segment.eachChar(function(ch) {\n                 var state;\n                 currentState = currentState.put(ch);\n             });\n             return currentState;\n         }\n         var RouteRecognizer = function() {\n             this.rootState = new State();\n             this.names = {};\n         };\n         RouteRecognizer.prototype = {\n             add: function(routes, options) {\n                 var currentState = this.rootState,\n                     regex = \"^\",\n                     types = {\n                         statics: 0,\n                         dynamics: 0,\n                         stars: 0\n                     },\n                     handlers = [],\n                     allSegments = [],\n                     name;\n                 var isEmpty = true;\n                 for (var i = 0,\n                         l = routes.length; i < l; i++) {\n                     var route = routes[i],\n                         names = [];\n                     var segments = parse(route.path, names, types);\n                     allSegments = allSegments.concat(segments);\n                     for (var j = 0,\n                             m = segments.length; j < m; j++) {\n                         var segment = segments[j];\n                         if (segment instanceof EpsilonSegment) {\n                             continue;\n                         }\n                         isEmpty = false;\n                         currentState = currentState.put({\n                             validChars: \"/\"\n                         });\n                         regex += \"/\";\n                         currentState = addSegment(currentState, segment);\n                         regex += segment.regex();\n                     }\n                     var handler = {\n                         handler: route.handler,\n                         names: names\n                     };\n                     handlers.push(handler);\n                 }\n                 if (isEmpty) {\n                     currentState = currentState.put({\n                         validChars: \"/\"\n                     });\n                     regex += \"/\";\n                 }\n                 currentState.handlers = handlers;\n                 currentState.regex = new RegExp(regex + \"$\");\n                 currentState.types = types;\n                 if (name = options && options.as) {\n                     this.names[name] = {\n                         segments: allSegments,\n                         handlers: handlers\n                     };\n                 }\n             },\n             handlersFor: function(name) {\n                 var route = this.names[name],\n                     result = [];\n                 if (!route) {\n                     throw new Error(\"There is no route named \" + name);\n                 }\n                 for (var i = 0,\n                         l = route.handlers.length; i < l; i++) {\n                     result.push(route.handlers[i]);\n                 }\n                 return result;\n             },\n             hasRoute: function(name) {\n                 return !!this.names[name];\n             },\n             generate: function(name, params) {\n                 var route = this.names[name],\n                     output = \"\";\n                 if (!route) {\n                     throw new Error(\"There is no route named \" + name);\n                 }\n                 var segments = route.segments;\n                 for (var i = 0,\n                         l = segments.length; i < l; i++) {\n                     var segment = segments[i];\n                     if (segment instanceof EpsilonSegment) {\n                         continue;\n                     }\n                     output += \"/\";\n                     output += segment.generate(params);\n                 }\n                 if (output.charAt(0) !== '/') {\n                     output = '/' + output;\n                 }\n                 if (params && params.queryParams) {\n                     output += this.generateQueryString(params.queryParams, route.handlers);\n                 }\n                 return output;\n             },\n             generateQueryString: function(params, handlers) {\n                 var pairs = [];\n                 var keys = [];\n                 for (var key in params) {\n                     if (params.hasOwnProperty(key)) {\n                         keys.push(key);\n                     }\n                 }\n                 keys.sort();\n                 for (var i = 0,\n                         len = keys.length; i < len; i++) {\n                     key = keys[i];\n                     var value = params[key];\n                     if (value == null) {\n                         continue;\n                     }\n                     var pair = encodeURIComponent(key);\n                     if (isArray(value)) {\n                         for (var j = 0,\n                                 l = value.length; j < l; j++) {\n                             var arrayPair = key + '[]' + '=' + encodeURIComponent(value[j]);\n                             pairs.push(arrayPair);\n                         }\n                     } else {\n                         pair += \"=\" + encodeURIComponent(value);\n                         pairs.push(pair);\n                     }\n                 }\n                 if (pairs.length === 0) {\n                     return '';\n                 }\n                 return \"?\" + pairs.join(\"&\");\n             },\n             parseQueryString: function(queryString) {\n                 var pairs = queryString.split(\"&\"),\n                     queryParams = {};\n                 for (var i = 0; i < pairs.length; i++) {\n                     var pair = pairs[i].split('='),\n                         key = decodeURIComponent(pair[0]),\n                         keyLength = key.length,\n                         isArray = false,\n                         value;\n                     if (pair.length === 1) {\n                         value = 'true';\n                     } else {\n                         if (keyLength > 2 && key.slice(keyLength - 2) === '[]') {\n                             isArray = true;\n                             key = key.slice(0, keyLength - 2);\n                             if (!queryParams[key]) {\n                                 queryParams[key] = [];\n                             }\n                         }\n                         value = pair[1] ? decodeURIComponent(pair[1]) : '';\n                     }\n                     if (isArray) {\n                         queryParams[key].push(value);\n                     } else {\n                         queryParams[key] = value;\n                     }\n                 }\n                 return queryParams;\n             },\n             recognize: function(path) {\n                 var states = [this.rootState],\n                     pathLen,\n                     i,\n                     l,\n                     queryStart,\n                     queryParams = {},\n                     isSlashDropped = false;\n                 queryStart = path.indexOf('?');\n                 if (queryStart !== -1) {\n                     var queryString = path.substr(queryStart + 1, path.length);\n                     path = path.substr(0, queryStart);\n                     queryParams = this.parseQueryString(queryString);\n                 }\n                 path = decodeURI(path);\n                 if (path.charAt(0) !== \"/\") {\n                     path = \"/\" + path;\n                 }\n                 pathLen = path.length;\n                 if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n                     path = path.substr(0, pathLen - 1);\n                     isSlashDropped = true;\n                 }\n                 for (i = 0, l = path.length; i < l; i++) {\n                     states = recognizeChar(states, path.charAt(i));\n                     if (!states.length) {\n                         break;\n                     }\n                 }\n                 var solutions = [];\n                 for (i = 0, l = states.length; i < l; i++) {\n                     if (states[i].handlers) {\n                         solutions.push(states[i]);\n                     }\n                 }\n                 states = sortSolutions(solutions);\n                 var state = solutions[0];\n                 if (state && state.handlers) {\n                     if (isSlashDropped && state.regex.source.slice(-5) === \"(.+)$\") {\n                         path = path + \"/\";\n                     }\n                     return findHandler(state, path, queryParams);\n                 }\n             }\n         };\n         RouteRecognizer.prototype.map = map;\n         RouteRecognizer.VERSION = 'VERSION_STRING_PLACEHOLDER';\n         return RouteRecognizer;\n     }());\n     var CHILD_ROUTE_SUFFIX = '/*childRoute';\n     var Grammar = function Grammar() {\n         this.rules = {};\n     };\n     (createClass)(Grammar, {\n         config: function(name, config) {\n             if (name === 'app') {\n                 name = '/';\n             }\n             if (!this.rules[name]) {\n                 this.rules[name] = new CanonicalRecognizer(name);\n             }\n             this.rules[name].config(config);\n         },\n         recognize: function(url) {\n             var componentName = arguments[1] !== (void 0) ? arguments[1] : '/';\n             var $__0 = this;\n             if (typeof url === 'undefined') {\n                 return;\n             }\n             var componentRecognizer = this.rules[componentName];\n             if (!componentRecognizer) {\n                 return;\n             }\n             var context = componentRecognizer.recognize(url);\n             if (!context) {\n                 return;\n             }\n             var lastContextChunk = context[context.length - 1];\n             var lastHandler = lastContextChunk.handler;\n             var lastParams = lastContextChunk.params;\n             var instruction = {\n                 viewports: {},\n                 params: lastParams\n             };\n             if (lastParams && lastParams.childRoute) {\n                 var childUrl = '/' + lastParams.childRoute;\n                 instruction.canonicalUrl = lastHandler.rewroteUrl.substr(0, lastHandler.rewroteUrl.length - (lastParams.childRoute.length + 1));\n                 forEach(lastHandler.components, (function(componentName, viewportName) {\n                     instruction.viewports[viewportName] = $__0.recognize(childUrl, componentName);\n                 }));\n                 instruction.canonicalUrl += instruction.viewports[Object.keys(instruction.viewports)[0]].canonicalUrl;\n             } else {\n                 instruction.canonicalUrl = lastHandler.rewroteUrl;\n                 forEach(lastHandler.components, (function(componentName, viewportName) {\n                     instruction.viewports[viewportName] = {\n                         viewports: {}\n                     };\n                 }));\n             }\n             forEach(instruction.viewports, (function(instruction, componentName) {\n                 instruction.component = lastHandler.components[componentName];\n                 instruction.params = lastParams;\n             }));\n             return instruction;\n         },\n         generate: function(name, params) {\n             var path = '';\n             var solution;\n             do {\n                 solution = null;\n                 forEach(this.rules, (function(recognizer) {\n                     if (recognizer.hasRoute(name)) {\n                         path = recognizer.generate(name, params) + path;\n                         solution = recognizer;\n                     }\n                 }));\n                 if (!solution) {\n                     return '';\n                 }\n                 name = solution.name;\n             } while (solution.name !== '/');\n             return path;\n         }\n     }, {});\n     Object.defineProperty(Grammar.prototype.recognize, \"parameters\", {\n         get: function() {\n             return [\n                 [$traceurRuntime.type.string],\n                 []\n             ];\n         }\n     });\n     var CanonicalRecognizer = function CanonicalRecognizer(name) {\n         this.name = name;\n         this.rewrites = {};\n         this.recognizer = new RouteRecognizer();\n     };\n     (createClass)(CanonicalRecognizer, {\n         config: function(mapping) {\n             var $__0 = this;\n             if (mapping instanceof Array) {\n                 mapping.forEach((function(nav) {\n                     return $__0.configOne(nav);\n                 }));\n             } else {\n                 this.configOne(mapping);\n             }\n         },\n         getCanonicalUrl: function(url) {\n             if (url[0] === '.') {\n                 url = url.substr(1);\n             }\n             if (url === '' || url[0] !== '/') {\n                 url = '/' + url;\n             }\n             forEach(this.rewrites, function(toUrl, fromUrl) {\n                 if (fromUrl === '/') {\n                     if (url === '/') {\n                         url = toUrl;\n                     }\n                 } else if (url.indexOf(fromUrl) === 0) {\n                     url = url.replace(fromUrl, toUrl);\n                 }\n             });\n             return url;\n         },\n         configOne: function(mapping) {\n             var $__0 = this;\n             if (mapping.redirectTo) {\n                 if (this.rewrites[mapping.path]) {\n                     throw new Error('\"' + mapping.path + '\" already maps to \"' + this.rewrites[mapping.path] + '\"');\n                 }\n                 this.rewrites[mapping.path] = mapping.redirectTo;\n                 return;\n             }\n             if (mapping.component) {\n                 if (mapping.components) {\n                     throw new Error('A route config should have either a \"component\" or \"components\" property, but not both.');\n                 }\n                 mapping.components = mapping.component;\n                 delete mapping.component;\n             }\n             if (typeof mapping.components === 'string') {\n                 mapping.components = {\n                     default: mapping.components\n                 };\n             }\n             var aliases;\n             if (mapping.as) {\n                 aliases = [mapping.as];\n             } else {\n                 aliases = mapObj(mapping.components, (function(componentName, viewportName) {\n                     return viewportName + ':' + componentName;\n                 }));\n                 if (mapping.components.default) {\n                     aliases.push(mapping.components.default);\n                 }\n             }\n             aliases.forEach((function(alias) {\n                 return $__0.recognizer.add([{\n                     path: mapping.path,\n                     handler: mapping\n                 }], {\n                     as: alias\n                 });\n             }));\n             var withChild = copy(mapping);\n             withChild.path += CHILD_ROUTE_SUFFIX;\n             this.recognizer.add([{\n                 path: withChild.path,\n                 handler: withChild\n             }]);\n         },\n         recognize: function(url) {\n             var canonicalUrl = this.getCanonicalUrl(url);\n             var context = this.recognizer.recognize(canonicalUrl);\n             if (context) {\n                 context[0].handler.rewroteUrl = canonicalUrl;\n             }\n             return context;\n         },\n         generate: function(name, params) {\n             return this.recognizer.generate(name, params);\n         },\n         hasRoute: function(name) {\n             return this.recognizer.hasRoute(name);\n         }\n     }, {});\n\n     function copy(obj) {\n         return JSON.parse(JSON.stringify(obj));\n     }\n\n     function forEach(obj, fn) {\n         Object.keys(obj).forEach((function(key) {\n             return fn(obj[key], key);\n         }));\n     }\n\n     function mapObj(obj, fn) {\n         var result = [];\n         Object.keys(obj).forEach((function(key) {\n             return result.push(fn(obj[key], key));\n         }));\n         return result;\n     }\n     return new Grammar();\n }]);\n"],"file":"router.es5.js","sourceRoot":"/source/"}